# 基于openGauss/.NET的餐饮服务系统

# 目录

- [1 绪论](#1---)
  * [**1.1** **餐饮服务系统**](#--11-------------)
  * [**1.2** **餐饮服务系统的发展历史和现状**](#--12---------------------)
  * [**1.3** **开发环境**](#--13-----------)
  * [**1.4** **本文的主要工作**](#--14--------------)
- [2 相关技术介绍](#2-------)
  * [**2.1** **openGauss数据库**](#--21-----opengauss-----)
  * [**2.2** **.NET平台**](#--22-----net----)
  * [**2.3** **Unity引擎**](#--23-----unity----)
- [3 需求分析](#3-----)
  * [**3.1 信息要求分析**](#--31---------)
  * [**3.2 处理要求分析**](#--32---------)
  * [**3.3 数据字典及安全性、完整性要求分析**](#--33-------------------)
- [4 概念结构设计](#4-------)
  * [**4.1 数据实体描述及其E-R图**](#--41---------e-r---)
  * [**4.2 完整E-R图**](#--42---e-r---)
- [5 逻辑结构设计](#5-------)
  * [**5.1 关系模式**](#--51-------)
  * [**5.2 关系模式的优化**](#--52----------)
  * [**5.3 关系数据模型**](#--53---------)
  * [**5.4系统功能模块**](#--54--------)
- [6 数据库物理设计](#6-------)
  * [**6.1 数据存储**](#--61-------)
- [7 系统详细设计](#7------)
  * [**7.1 数据库实施**](#--71--------)
  * [**7.2 数据库备份与恢复**](#--72-----------)
  * [**7.3 服务端实现**](#--73--------)
  * [**7.4客户端实现**](#--74-------)
- [8 系统测试](#8----)
  * [**8.1 测试方案**](#--81-------)
  * [**8.2 测试报告**](#--82-------)
    + [**8.2.1服务端与客户端建立TCP/IP连接测试**](#--821---------tcp-ip------)
    + [**8.2.2 登录注册功能测试**](#--822-----------)
    + [**8.2.3管理员管理功能测试**](#--823-----------)
    + [**8.2.4顾客下单功能测试**](#--824----------)
- [9 安装和使用说明](#9-------)
  * [**9.1 安装说明**](#--91-------)
  * [**9.2 使用说明**](#--92-------)
- [10 总结与展望](#10-----)
  * [**10.1 个人总结**](#--101-------)
  * [**10.2 未来展望**](#--102-------)
- [11 参考文献](#11----)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>

# 1 绪论

## **1.1** **餐饮服务系统**

餐饮服务系统是从餐饮企业的特征和实际需求出发：为餐饮服务人员提供智能化高效管理等功能，为消费者提供舒适便捷点餐等服务的系统。

系统适用于中餐酒楼、西餐厅、快餐、酒吧、茶楼、咖啡厅等大中小型餐饮企业。

## **1.2** **餐饮服务系统的发展历史和现状**

随着我国市场经济的快速发展，各行业都呈现出生机勃勃的发展景象，其中餐饮业的发展尤为突出。近两年来已呈现出高速发展的态势。据统计，我国30万家饭店，年营业总额达6300多亿元。成为国内消费需求市场中发展最快的行业。但在快速发展的同时，餐饮业在日常经营管理中仍普遍采用手工管理方式，整体科技含量低。随着餐饮企业规模和数量的不断增长，手工管理模式无论是在工作效率、人员成本还是提供决策信息方面都已难以适应现代化经营管理的要求，因此制约了整个餐饮业的规模化发展和整体服务水平的提升。

近年来，随着改革开放步伐的加快，人民群众的生活水平得到了极大的提高，再加之国内社会对第三产业特别是餐饮服务业的需求也越来越高。但餐饮行业自身在快速发展的同时，也遇到了一些急待解决的难题。一方面，国内投资者纷纷涉足餐饮业使餐饮经营企业数量不断增加，国内市场竞争日趋激烈；另一方面，国外大型的饭店管理集团已待机大举进入我国餐饮业，更加剧了市场竞争的激烈程度。可以说今天的餐饮业已不再是投资少、利润高的行业，而变成了一个投资高、风险大的行业。作为行业中的每一位经营者来说如何能在这种越来越激烈的竞争中立于不败之地并能谋求进一步发展壮大，这应该是他们都要考虑的现实问题。在科技高速发展的今天，要想实现这个目标，离不开最为关键的一点，就是要在餐饮业中实现信息化管理。从根本上改变以前那种旧的管理模式真正做到提高管理和服务水平的目的。 在全国众多的餐饮企业中广大的中小型饭店无疑是整个餐饮行业的中坚力量。无论是从数量以及分布的广度上还是从经济总量上它们都已成为行业的主体。广大中小型饭店管理水平的提高对整个餐饮行业的发展会起到决定性的促进作用。但往往在这些饭店中进行有效的管理是一个难题，突出表现为缺乏正规的管理理念和经验；员工培训和整体素质与现代企业存在较大差距；业务流程中存在诸多漏洞等问题。为能有效的解决这些问题提高企业的经济效益，在这些中小型饭店中实施计算机管理信息系统不视为一条有效的解决途径。

## **1.3** **开发环境**

操作系统：Windows 11、CentOS

编译环境：.NET 6.0、C\#

编译工具：Visual Studio 2022

## **1.4** **本文的主要工作**

本文的主要工作是在CentOS系统上使用openGauss数据库设计了一个简易的餐饮服务数据库，并在Windows系统上采用C/S架构设计了一个.NET的后台服务器和基于Unity引擎实现的图形界面客户端。通过数据库、服务器和客户端三者的配合提供一个系统后台服务的模型，来模拟实现日常的餐饮企业基本业务。主要工作如下：

1.  分析了系统需求；
2.  进行了系统数据库的设计、建立和完善；
3.  详细分析了餐饮服务系统C/S架构的实现细节；
4.  完成了餐饮服务系统中.NET服务端的开发设计与调试优化。
5.  完成了餐饮服务系统中Unity客户端的开发设计与调试优化。

# 2 相关技术介绍

## **2.1** **openGauss数据库**

openGauss数据库是华为深度融合在数据库领域多年经验，结合企业级场景要求推出的新一代企业级开源数据库。openGauss是关系型数据库，采用客户端/服务器，单进程多线程架构；支持单机和一主多备部署方式，同时支持备机可读、双机高可用等特性。

openGauss支持以下基本功能：

**①标准SQL支持：**支持标准的SQL92/SQL99/SQL2003/SQL2011规范，支持GBK和UTF-8字符集，支持SQL标准函数与分析函数，支持存储过程。

**②数据库存储管理功能：**支持表空间，可以把不同表规划到不同的存储位置。

**③提供主备双机：**事务支持ACID特性、单节点故障恢复、双机数据同步，双机故障切换等。

**④应用程序接口：**支持标准JDBC 4.0的特性、ODBC 3.5特性。

**⑤管理工具：**提供安装部署工具、实例启停工具、备份恢复工具。

**⑥安全管理：**支持SSL安全网络连接、用户权限管理、密码管理、安全审计等功能，保证数据库在管理层、应用层、系统层和网络层的安全性。

本文利用openGauss标准SQL支持等基本功能在CentOS系统上搭建了餐饮服务数据库。

## **2.2** **.NET平台**

.NET是一种用于构建多种应用的免费开源开发平台，可以使用多种语言，编辑器和库开发Web应用、Web API和微服务、云中的无服务器函数、云原生应用、移动应用、桌面应用、Windows WPF、Windows窗体、通用 Windows平台 (UWP)、游戏、物联网 (IoT)、机器学习、控制台应用、Windows服务。.NET类库在不同应用和应用类型中共享功能，无论构建哪种类型的应用，代码和项目文件看起来都一样，可以访问每个应用的相同运行时、API和语言功能。

本文利用.NET 6.0的控制台应用设计了餐饮服务系统的服务端。

## **2.3** **Unity引擎**

Unity引擎是一款支持2D/3D等多维度图形界面设计，游戏内容创作的引擎。其底层支持OpenGL和Direct11等图形API，支持Java Script、C\#、Boo脚本语言。作为一款开发工具，Unity性能卓越，同时可以高效编辑脚本，支持可视化编程界面完成各种开发工作。

本文使用C\#作为脚本语言借助Unity引擎完成餐饮服务系统中图形交互界面的设计和实现。

# 3 需求分析

## **3.1 信息要求分析**

所有使用该系统的用户使用账号登录该系统。 餐厅的管理人员可以通过该系统管理菜单的信息，包括新增菜品信息、修改菜品信息和删除菜品信息，同时可以修改菜品的库存信息。新顾客可以注册账号后登录系统，顾客可以通过该系统查看菜单的信息，挑选想要的菜品并加入购物车，填写收获地址并提交订单。

## **3.2 处理要求分析**

**用户账号信息管理**——顾客可以在登录界面输入账号ID，姓名，电话号码来注册账号，并使用账号ID和电话来登录系统。管理员可以在登录界面输出账号ID和电话号码来登录系统。

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201930724-799807938.png)

图3.1账号信息管理数据流图

**菜单信息管理**——管理员查看菜单的所有信息，新增，修改和删除菜单信息，包括食品的名称，规格和对应的单价以及具体的食品简介。顾客可以查看菜单的食品介绍信息和价格信息，不能对菜单进行修改。

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201931307-463776022.png)

图3.2菜单信息管理数据流图

**库存信息管理**——管理员查看所有菜品的库存信息，并更加餐厅的实际库存量对系统上的库存信息进行更新和修改。

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201931902-384262019.png)

图3.3库存信息管理数据流图

**订单信息管理**——顾客可以挑选食品加入购物车，并随时修改购物车中的食品，最后输入收获地址将购物车中的食品生成订单。同时系统自动根据购物车内容生成该订单的详细清单。

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201932676-367791315.png)

图3.4 订单信息管理数据流图

## **3.3 数据字典及安全性、完整性要求分析**

**数据字典**

customer表：存储客户的个人信息

| **字段名** | **类型**    | **注释及说明** |
| ---------- | ----------- | -------------- |
| cus_id     | integer     | 顾客编号       |
| cus_name   | varchar(50) | 顾客名称       |
| cus_phone  | varchar(11) | 顾客手机号码   |

表3.1 customer表

admin表：存储管理员的个人信息

| **字段名** | **类型**    | **注释及说明**     |
| ---------- | ----------- | ------------------ |
| a_id       | integer     | 管理员编号（主键） |
| a_name     | varchar(50) | 管理员名称         |
| a_phone    | varchar(11) | 管理员手机号       |

表3.2 admin表

menu表：存储食品的信息

| **字段名**     | **类型**     | **注释及说明** |
| -------------- | ------------ | -------------- |
| mu_id          | integer      | 食品编号(主键) |
| mu_food        | varchar(50)  | 食品名称       |
| mu_description | varchar(255) | 食品描述       |

表3.3 menu表

inventory表：食品库存情况

| **字段名** | **类型** | **注释及说明**                                |
| ---------- | -------- | --------------------------------------------- |
| i_mu_id    | integer  | 食品编号(外键，与menu表的mu_id级联删除和更新) |
| i_remain   | integer  | 食品剩余库存                                  |

表3.4 inventory表

size表：存储菜品规格与价格信息

| **字段名** | **类型**   | **注释及说明**                                |
| ---------- | ---------- | --------------------------------------------- |
| s_id       | integer    | 规格编号(主键)                                |
| s_mu_id    | integer    | 食品编号(外键，与menu表的mu_id级联删除和更新) |
| s_size     | varchar(4) | 食品规格（小、中、大）                        |
| s_price    | float      | 食品价格                                      |

表3.5 size表

order表：存储订单信息

| **字段名** | **类型**     | **注释及说明**                                               |
| ---------- | ------------ | ------------------------------------------------------------ |
| o_id       | integer      | 订单编号(主键)                                               |
| o_cus_id   | integer      | 下单顾客即用户编号(外键，与customer表的cus_id级联删除和更新) |
| o_price    | float        | 总价格                                                       |
| o_address  | varchar(255) | 送餐地点                                                     |

表3.6 order表

list表：存储订单的详细信息

| **字段名** | **类型** | **注释及说明**                                |
| ---------- | -------- | --------------------------------------------- |
| l_o_id     | integer  | 订单编号(外键，与order表的o_id级联删除和更新) |
| l_s_id     | integer  | 规格编号(外键，与size表的s_id级联删除和更新)  |

表3.7 list表

**安全性要求分析：**

数据库的安全性保护数据库以防止不合法使用所造成的数据泄漏、更改或破坏；

**数据库的不安全因素**：

1.  非授权用户对数据库的恶意存取和破坏。
2.  数据库中重要或敏感的数据被泄露。
3.  安全环境的脆弱与操作系统的安全性、网络协议安全保障等。

针对上述不安全因素，分析得出需要以下几个安全要求：

1.  用户身份限制：限制管理员账号的注册权限，防止对菜单等数据库的恶意存取和破坏。
2.  设置数据库存储控制：确保只授权给有资格的用户访问数据库的权限；
3.  定义用户权限：顾客只能执行顾客所能操作的功能，管理员的功能顾客不能操作；
4.  数据加密：将要存储和传输的数据进行加密；

**完整性要求分析：**

数据库中数据的完整性要求**数据的正确、有效、相容**。**实体完整性要求**检查主码是否唯一，检查主码各个属性是否为空，同时**在主码自动建立索引，避免全表扫描；用户定义的完整性则要求**列值非空（ NOT NULL），列值唯一（ UNIQUE），检查列值是否满足一个条件表达式（ CHECK短语）。

针对上述要求，采取以下几种方法：

1.  **针对建立检查语句（check短语）进行字段数据格式判断；**
2.  **增加外键关系约束，通过设置级联更新和级联删除等方式来实现数据完整性操作；**

# 4 概念结构设计

## **4.1 数据实体描述及其E-R图**

1.  管理员(admin)包含管理员编号，管理员姓名，管理员电话，其E-R图如下：

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201933518-9332883.png)

图4.1 管理员E-R图

1.  顾客(customer)包含顾客编号，顾客姓名，顾客电话，其E-R图如下：

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201934111-1797993721.png)

图4.2 顾客E-R图

1.  菜品(menu)包含食品编号，食品名称，食品简介，其E-R图如下：

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201934814-341350167.png)

图4.3 菜品E-R图

1.  食品库存(inventory)包含食品编号,食品剩余库存，其E-R图如下：

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201935192-765849636.png)

图4.4 食品库存E-R图

1.  食品规格(size)包含规格编号，食品编号，食品规格（小、中、大），食品价格，其E-R图如下：

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201935617-1296155219.png)

图4.5 食品规格E-R图

1.  订单(order)包含订单编号，下单顾客即用户编号，总价格，送餐地点其E-R图如下：

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201935964-448895811.png)

图4.6 订单E-R图

1.  订单详情(list)包含订单编号，食品规格编号，其E-R图如下：

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201936258-472822903.png)

图4.7 订单详情E-R图

## **4.2 完整E-R图**

以下是将本餐饮服务系统的各个基本实体进行联系后得到的完整E-R图：

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201936725-128738865.png)

图4.8 餐饮服务系统完整E-R图

其中的关系总结如下：

1.  一种菜品对应一份食品库存信息，是一对一的关系；
2.  一种菜品可以有多种食品规格，是一对多的关系；
3.  不同的订单可以包含不同种类和数量的菜品，是多对多的关系；
4.  一个订单中包含多个订单详情信息，属于一对多的关系；
5.  一名顾客可以拥有多个订单，属于一对多的关系；
6.  不同管理员都可以管理所有的菜品信息，属于多对多的关系；

# 5 逻辑结构设计

## **5.1 关系模式**

根据上文图4.8的系统E-R图及E-R图模型与关系模式的转化规则，得到本文餐饮服务系统数据库的关系模式如下：

菜品（食品编号，食品名称，食品简介）

食品库存（食品编号，食品剩余库存）

食品规格（食品规格编号，食品规格，食品价格）

订单（订单编号，用户编号，总价格，送餐地点）

订单详情（订单编号，食品规格编号）

顾客（顾客编号，顾客姓名，顾客电话）

管理员（管理员编号，管理员姓名，管理员电话）

订单菜品（订单编号，食品编号）

## **5.2 关系模式的优化**

1. **菜品**

   U={食品编号，食品名称，食品简介}

   F={食品编号—\>食品名称，食品编号—\>食品简介}

   Fmin={食品编号—\>食品名称，食品编号—\>食品简介}

   无部分依赖，无传递依赖，满足3NF要求。

2. **食品库存**

   U={食品编号，食品剩余库存}

   F={食品编号—\>食品剩余库存}

   Fmin={食品编号—\>食品剩余库存}

   无部分依赖，无传递依赖，满足3NF要求。

3. **食品规格**

   U={食品规格编号，食品规格，食品价格}

   F={食品规格编号—\>食品规格，食品规格编号—\>食品价格}

   Fmin={食品规格编号—\>食品规格，食品规格编号—\>食品价格}

   无部分依赖，无传递依赖，满足3NF要求。

4. **订单**

   U={订单编号，用户编号，总价格，送餐地点}

   F={订单编号—\>用户编号，订单编号—\>总价格，订单编号—\>送餐地点}

   Fmin={订单编号—\>用户编号，订单编号—\>总价格，订单编号—\>送餐地点}

   无部分依赖，无传递依赖，满足3NF要求。

5. **订单详情**

   U={订单编号，食品规格编号}

   F= Fmin={ }

   无部分依赖，无传递依赖，属于3NF。

6. **顾客**

   U={顾客编号，顾客姓名，顾客电话}

   F={顾客编号—\>顾客姓名，顾客编号—\>顾客电话}

   Fmin={顾客编号—\>顾客姓名，顾客编号—\>顾客电话}

   无部分依赖，无传递依赖，满足3NF要求。

7. **管理员**

   U={管理员编号，管理员姓名，管理员电话}

   F={管理员编号—\>管理员姓名，管理员编号—\>管理员电话}

   Fmin={管理员编号—\>管理员姓名，管理员编号—\>管理员电话}

   无部分依赖，无传递依赖，满足3NF要求。

8. **订单菜品**

   U={订单编号，食品编号}

   F= Fmin={ }

   无部分依赖，无传递依赖，属于3NF。

## **5.3 关系数据模型**

使用数据库管理工具Navicat连接openGauss数据库后，选中本文中的餐饮服务系统使用的restaurant数据库，逆向生成关系数据模型如下：

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201937219-626914827.png)

图5.1 本文餐饮服务系统数据库的关系数据模型

## **5.4系统功能模块**

1.  服务端功能模块

服务端负责连接数据库并与客户端进行TCP/IP通信。具体如下，服务端在启动后通过Npgsql API提供的接口连接openGauss数据库，随后初始化socket并开启监听等待客户端的连接。当与客户端成功建立连接后，等待客户端发送的数据请求。当接收到客户端发送的数据报后，解析数据报并生成对应的SQL语句，将SQL语句送往数据库中执行并接收数据库返回的数据或结果，最后再将数据封装好后以数据报形式发回给客户端。

以下是服务端的功能模块图：

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201937591-1419074568.png)

图5.2 服务端功能模块图

1.  客户端功能模块

客户端负责为系统用户提供图形交互界面与数据的可视化处理。具体如下，客户端在启动后尝试与服务端建立TCP/IP连接，成功连接后等待系统用户输入账号等信息注册或登录。实时处理用户的输入请求，检查用户的输入是否合法，当检测到非法输入或尝试进行违反数据库原则的操作时进行消息提示。

当用户请求登录请求时，客户端将用户编号封装作为查询条件发送给服务端并接收服务端发送的该用户的手机号，比对用户输入与服务端发送来的手机号一致无误后表示登录成功，随后客户端根据登录用户的身份跳转到管理员管理界面或用户下单界面。

在管理界面，客户端会发送菜品和库存等数据的获取请求给服务端，待服务端发来所需数据后解析数据报并进行可视化处理。管理员可以通过界面的UI查看可以管理的数据，并借助输入框和按钮等实现对菜品及库存数据的增加、删除和修改。客户端会对所有操作的结果进行文本消息提示，若管理员操作成功，还会同步更新可视化窗口的内容。

在下单界面，客户端会发送顾客菜单获取的请求给服务端并同样可视化接收到的菜单数据。顾客可以浏览菜单并借助输入框下单，客户端会缓存用户的订单内容并可视化，方便顾客增加或删除购物车中的菜品。同时客户端实时计算并显示当前订单的总价。当顾客完成菜品的挑选后，可以输入送餐地址并确认下单。客户端会将本地缓存的订单内容打包封装成数据报发送给服务端，当收到服务端成功的回复后提示顾客下单成功。

以下是客户端的功能模块图：

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201937953-264242161.png)

图5.3 客户端功能模块图

# 6 数据库物理设计

## **6.1 数据存储**

对于字符串类型的数据，定长的字符串例如手机号就采用固定11位的char类型进行保存，对于非定长的字符串，比如顾客送餐地址等就用varchar类型来保存，这样可以较好的节省存储空间；

**数据库物理存储结构**

| **字段名** | **类型**    | **约束**   |
| ---------- | ----------- | ---------- |
| cus_id     | integer     | 主键，非空 |
| cus_name   | varchar(50) | 非空       |
| cus_phone  | varchar(11) | 非空       |

表6.1 customer表

| **字段名** | **类型**    | **约束**   |
| ---------- | ----------- | ---------- |
| a_id       | integer     | 主键，非空 |
| a_name     | varchar(50) | 非空       |
| a_phone    | varchar(11) | 非空       |

表6.2 admin表

| **字段名**     | **类型**     | **约束**   |
| -------------- | ------------ | ---------- |
| mu_id          | integer      | 主键，非空 |
| mu_food        | varchar(50)  | 非空       |
| mu_description | varchar(255) | 非空       |

表6.3 menu表

| **字段名** | **类型** | **约束**               |
| ---------- | -------- | ---------------------- |
| i_mu_id    | integer  | 外键级联更新删除，非空 |
| i_remain   | integer  | 非空                   |

表6.4 inventory表

| **字段名** | **类型**   | **约束**               |
| ---------- | ---------- | ---------------------- |
| s_id       | integer    | 主键，非空             |
| s_mu_id    | integer    | 外键级联更新删除，非空 |
| s_size     | varchar(4) | 非空                   |
| s_price    | float      | 非空                   |

表6.5 size表

| **字段名** | **类型**     | **约束**               |
| ---------- | ------------ | ---------------------- |
| o_id       | integer      | 主键，非空             |
| o_cus_id   | integer      | 外键级联更新删除，非空 |
| o_price    | float        | 非空                   |
| o_address  | varchar(255) | 非空                   |

表6.6 order表

| **字段名** | **类型** | **约束**               |
| ---------- | -------- | ---------------------- |
| l_o_id     | integer  | 外键级联更新删除，非空 |
| l_s_id     | integer  | 外键级联更新删除，非空 |

表6.7 list表

# 7 系统详细设计

## **7.1 数据库实施**

1. 创建管理员(admin)表：

   ```sql
   CREATE TABLE admin( a_id INTEGER PRIMARY KEY NOT NULL, a_name varchar(50) NOT NULL, a_phone varchar(11) NOT NULL);
   ```

2. 创建顾客(customer)表：

   ```sql
   CREATE TABLE customer( cus_id INTEGER PRIMARY KEY NOT NULL, cus_name VARCHAR(50) NOT NULL, cus_phone VARCHAR(11) NOT NULL,);
   ```


3. 创建菜品(menu)表：

   ```sql
   CREATE TABLE menu( mu_id INTEGER PRIMARY KEY NOT NULL, mu_food VARCHAR(50) NOT NULL, mu_description VARCHAR(255) NOT NULL);
   ```

4. 创建食品库存(inventory)表：

   ```sql
   CREATE TABLE inventory( i_mu_id INTEGER NOT NULL, i_remain INTEGER NOT NULL, FOREIGN KEY (i_mu_id) REFERENCES menu(mu_id)) ON DELETE CASCADE ON UPDATE CASCADE);
   ```

5. 创建食品规格(size)表：

   ```sql
   CREATE TABLE size( s_id INTEGER PRIMARY KEY NOT NULL, s_mu_id INTEGER NOT NULL, s_size CHAR(1) NOT NULL, s_price FLOAT(2) NOT NULL, FOREIGN KEY (s_mu_id) REFERENCES menu(mu_id) ON DELETE CASCADE ON UPDATE CASCADE);
   ```

6. 创建订单(order)表：

   ```sql
   CREATE TABLE order( o_id INTEGER PRIMARY KEY NOT NULL, o_cus_id INTEGER NOT NULL, o_price FLOAT(2) NOT NULL, o_address VARCHAR(255) NOT NULL, FOREIGN KEY (o_cus_id) REFERENCES customer(cus_id) ON DELETE CASCADE ON UPDATE CASCADE);
   ```

7. 创建订单详情(list)表：

   ```sql
   CREATE TABLE list( o_cus_id INTEGER NOT NULL, o_s_id INTEGER NOT NULL, FOREIGN KEY (o_cus_id) REFERENCES customer(cus_id) ON DELETE CASCADE ON UPDATE CASCADE); FOREIGN KEY (o_s_id) REFERENCES size(s_id) ON DELETE CASCADE ON UPDATE CASCADE);
   ```

 

## **7.2 数据库备份与恢复**

数据备份是保护数据安全的重要手段之一，为了更好的保护数据安全，openGauss数据库支持两种备份恢复类型、多种备份恢复方案，备份和恢复过程中提供数据的可靠性保障机制。备份与恢复类型可分为逻辑备份与恢复、物理备份与恢复。

1.  **逻辑备份与恢复：**

通过逻辑导出对数据进行备份，逻辑备份只能基于备份时刻进行数据转储，所以恢复时也只能恢复到备份时保存的数据。对于故障点和备份点之间的数据，逻辑备份无能为力，逻辑备份适合备份那些很少变化的数据，当这些数据因误操作被损坏时，可以通过逻辑备份进行快速恢复。如果通过逻辑备份进行全库恢复，通常需要重建数据库，导入备份数据来完成，对于可用性要求很高的数据库，这种恢复时间太长，通常不被采用。由于逻辑备份具有平台无关性，所以更为常见的是，逻辑备份被作为一个数据迁移及移动的主要手段。

**具体方案：适用于数据量小场景的逻辑备份方案**

| 应用场景   | 可以备份单表和多表，单database和所有database。备份后的数据需要使用gsql或者gs_restore工具恢复，当数据量大时，恢复需要较长时间。 |
| ---------- | ------------------------------------------------------------ |
| 支持的介质 | 磁盘SSD                                                      |
| 工具的名称 | gs_dump、gs_dumpall                                          |
| 恢复时间   | gs_dump：纯文本格式数据恢复时间长。归档格式数据恢复时间中等。 gs_dumpall：数据恢复时间长。 |

表7.2 数据库逻辑备份与恢复方案

1.  **物理备份与恢复：**

通过物理文件拷贝的方式对数据库进行备份，以磁盘块为基本单位将数据备份。通过备份的数据文件及归档日志等文件，数据库可以进行完全恢复。物理备份速度快，一般被用作对数据进行备份和恢复，用于全量备份的场景。通过合理规划，可以低成本进行备份与恢复。

**具体方案：适用于数据量大场景的物理备份方案**

| 应用场景   | 适用于数据量大的场景，主要用于全量数据备份恢复，也可对整个数据库中的WAL归档日志和运行日志进行备份。 |
| ---------- | ------------------------------------------------------------ |
| 支持的介质 | 磁盘SSD                                                      |
| 工具的名称 | gs_backup、gs_basebackup、gs_probackup                       |
| 恢复时间   | gs_dump：数据量小数据恢复时间快。 gs_basebackup：恢复时可以直接拷贝替换原有的文件， 或者直接在备份的库上启动数据库，恢复时间快。 gs_probackup：恢复时可以直接恢复到某个备份点，在备份的库上启动数据库，恢复时间快。 |

表7.3 数据库物理备份与恢复方案

## **7.3 服务端实现**

> 详见Server文件夹

## **7.4客户端实现**

> 详见Client文件夹

# 8 系统测试

## **8.1 测试方案**

对本系统的采用分功能模块测试，先在客户端通过交互界面进行餐饮服务的管理模拟，将客户端中可视化的数据及得到的操作的结果与借助Navicat工具连接数据库后可视化得到的结果进行比较，若结果一致，可验证该系统功能实现的正确性。

## **8.2 测试报告**

**测试环境说明：**

| **环境**   | **说明**                     |
| ---------- | ---------------------------- |
| 数据库环境 | CentOS 6(使用VirtualBox运行) |
| 服务端环境 | Windows 11                   |
| 客户端环境 | Windows 11                   |

表8.1系统测试环境说明

### **8.2.1服务端与客户端建立TCP/IP连接测试**

**测试方案：**

先运行服务端，随后运行客户端，观察服务端输出。

**测试结果：**

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201938318-1874893155.png)

图8.1 服务端与客户端建立TCP/IP连接测试结果

**结果分析：**

观察发现客户端127.0.0.1:11033连接成功，说明服务端与客户端建立 TCP/IP连接功能正常。

### **8.2.2 登录注册功能测试**

**测试方案：**

模拟顾客使用系统，注册一个新的顾客账号（ID：123，昵称：小江，电话：13877889900）。随后使用新注册的账号以顾客身份登录该系统。测试过程中进行如下操作并观察系统反应：①尝试输入非法的电话号码；②尝试以未注册的账号和电话进行登录验证；③尝试不输入电话进行登录验证；

最后使用Navicat连接系统数据库，观察顾客新注册的账号信息是否被正确添加到customer表中。

**测试结果：**

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201943273-291249454.png)

图8.2 尝试输入非法的电话号码测试结果

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201949980-400107445.png)

图8.3 尝试以未注册的账号和电话进行登录验证测试结果

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201953657-836329778.png)

图8.4 尝试不输入电话进行登录验证测试结果

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201957104-709600212.png)

图8.5顾客正确输入信息注册账号测试结果

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201957736-1536338036.png)

图8.6使用Navicat查看账号测试结果

**结果分析：**

当在系统登录界面进行①②③测试操作时，系统均给出相应文字消息提示并正确处理了用户错误的输入操作。最后成功注册新账户，通过Navicat查看customer表也能看到新的顾客账号信息确实成功插入数据库中，证明系统的登录注册功能正常。

### **8.2.3管理员管理功能测试**

**测试方案：**

以管理员身份登录系统，观察系统是否能正确获取菜单信息，并将客户端可视化的信息与Navicat中可视化的结果进行比较看是否一致。随后对菜单进行增加、删除和修改的操作，具体方案如下：

①增加编号为1011的食品红烧牛肉面，添加简介及两种规格和对应单价。随后设置该食品的库存。

②修改编号为5002的食品鳕鱼堡的食品名称为金枪鱼汉堡，并修改相应简介，同时调整价格。随后调整该食品的库存。

③删除编号为1002的食品espressoX2。

同时修改对应的库存信息，每次修改后都在Navicat中进行一致性检验。

**测试结果：**

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201958676-798342318.png)

图8.7 管理界面菜单及库存获取测试结果

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201959121-1032735505.png)

图8.8 使用Navicat查看的数据库menu表（部分）![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201959443-919954163.png)

图8.9 使用Navicat查看的数据库size表（部分）

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506201959770-221501986.png)

图8.10 使用Navicat查看的数据库inventory表（部分）

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506202000625-1400146814.png)

图8.11 添加新的食品及食品规格的测试结果

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506202001126-1670455250.png)

图8.12 使用Navicat查看的数据库menu表中新菜品的添加情况

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506202002064-1292351424.png)

图8.13 修改食品及食品规格的测试结果

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506202002525-957669785.png)

图8.14 使用Navicat查看的数据库menu表中编号为5002的食品的修改情况

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506202003432-1580839100.png)

图8.15 删除食品及食品规格的测试结果

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506202003912-948967543.png)

图8.16 使用Navicat查看的数据库menu表中编号为1002的食品的删除情况

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506202004247-196146376.png)

图8.17 使用Navicat查看的数据库inventory表中食品库存的情况

**结果分析：**

从图8.7-图8.10的测试结果截图可以看出客户端管理界面获取的菜单和库存信息无误，验证该功能准确无误。从图8.8-图8.16的测试结构截图可以看出客户端管理界面增加、删除和修改菜单及其库存信息的结果准确无误，验证该功能正常。

### **8.2.4顾客下单功能测试**

**测试方案：**

以顾客身份登录系统，观察系统是否能正确获取菜单信息，并将客户端可视化的信息与Navicat中可视化的结果进行比较看是否一致。随后模拟顾客的下单操作，具体方案如下：

①添加一份大份的Flat White，一份中份的红茶和一份小份的肉酱意大利面到购物车中。

②删除购物车中的Flat White。

③填写地址：“广东工业大学大学城校区校区生活西区”并下单。

**测试结果：**

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506202005675-1820687757.png)

图8.18 顾客下单界面菜单获取测试结果

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506202006128-130418452.png)

图8.19 使用Navicat查看的数据库cus_menu_view视图（部分）![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506202007505-2029357938.png)

图8.20 顾客添加菜品到购物车中的测试结果

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506202008986-1462328873.png)

图8.21 顾客从购物车中删除菜品的测试结果

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506202010506-627475717.png)

图8.22 顾客填写地址后确认下单的测试结果

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506202010992-877985444.png)图8.23 使用Navicat查看的数据库order表中新订单的添加情况

![](https://img2023.cnblogs.com/blog/2556266/202305/2556266-20230506202011334-688168536.png)

图8.24 使用Navicat查看的数据库list表中新订单详情的添加情况

**结果分析：**

从图8.18-图8.19的测试结果截图可以看出客户端顾客下单界面获取顾客菜单显示结果准确，验证该菜单获取功能正常。从图8.20-图8.24的测试结果截图可以看出顾客添加菜品，修改删除购物车中菜品的功能正常，对应数据库表中的订单数据添加准确无误，验证该顾客下单功能正常。

# 9 安装和使用说明

## **9.1 安装说明**

由于本系统的数据库建立在本地的CentOS系统中，因此数据库的安装需要通过迁移虚拟机中CentOS的镜像文件。并通过Virtual Box导入镜像完成数据库的安装准备。

服务端为Windows系统的终端控制台程序，双击RestaurantSystemServer.exe文件即可启动，无需安装。

客户端安装包解压后，双击RestaurantSystem.exe文件即可启动客户端。

## **9.2 使用说明**

首先需要在CentOS系统中使用root账户登录并切换到omm用户，通过gs_om -t start指令启动数据库。随后启动服务端，最后启动客户端，系统会自动完成三者的连接和初始化。

# 10 总结与展望

## **10.1 个人总结**

这次数据库系统课程设计确实下了不少功夫。由于是第一次尝试C/S架构的系统开发。因此在完成了前期的需求分析和数据库的概念设计后，还需要花费比较多的时间学习 .net服务器的搭建，同时由于Unity多用来开发单机的游戏，这也是我第一次使用Untiy来实现网络编程，并利用里面的UGUI等组件实现数据的可视化和用户的交互处理。整个系统从头到尾实打实做了半个多月，服务端和客户端总代码量也超过了3000行，因此工作量上感觉是足够的。

在开发的过程中遇到了很多理论学习时没有遇到或注意的问题。例如，由于各大开发工具对openGauss数据库的支持还不像MySQL或SQLServer一样完善，在使用.net服务端连接openGauss数据库时得借助第三方用于连接Postgresql数据库的API——Npgsql来实现。这部分的学习虽然难度较大，但也让我受益匪浅。同时，在不断翻阅openGauss文档并与其它主流关系数据库进行对比的过程也加深了我对openGauss数据库的理解。

## **10.2 未来展望**

由于前期的学习成本较高，同时时间比较紧张，因此其实这次的系统还有许多可以完善的部分。例如在顾客下单后，管理员可以接受、查看与完成订单。同时可以增加如今常用的会员管理系统管理顾客。同时对于可以堂食的餐厅可以增加餐桌管理功能模块等。后续有时间将完善该系统的概念设计，并不断完善更多功能，同时增强该系统的安全性（如对网络通信的数据报文进行加密），提高运行速度（使用多线程技术等）。

# 11 参考文献

1.  王珊.萨师煊. 数据库系统概论（5版） [M].北京.高等教育出版社, 2014.9
2.  罗培羽. Unity3D网络游戏实战 [M].北京.机械工业出版社,2016.10
3.  openGauss2.0.0版本使用手册(<https://www.bookstack.cn/books/opengauss-2.0-zh/>)
4.  Microsoft.NET:C\#开发文档(<https://learn.microsoft.com/zh-cn/dotnet/csharp/>)
5.  Npgsql开发文档(<https://www.npgsql.org/doc/>)
6.  Unity开发文档(<https://docs.unity3d.com/cn/2021.3/Manual/UnityManual.html>)
